Semiquantum key distribution with secure delegated quantum computation
Semiquantum key distribution allows a quantum party to share a random key with a “classical” party who only can prepare and measure qubits in the computational basis or reorder some qubits when he has access to a quantum channel. In this work, we present a protocol where a secret key can be established between a quantum user and an almost classical user who only needs the quantum ability to access quantum channels, by securely delegating quantum computation to a quantum server. We show the proposed protocol is robust even when the delegated quantum server is a powerful adversary and is experimentally feasible with current technology. As one party of our protocol is the most quantum-resource efficient, it can be more practical and significantly widen the applicability scope of quantum key distribution.
Conventionally quantum key distribution requires that two remote parties (usually called Alice and Bob) should have somewhat quantum capabilities to establish a shared key, such as the ability of preparing and measuring qubits in different bases. However, not all of the users own enough quantum resources or have equal quantum technologies in reality. Moreover, a protocol sometimes may not need to be completely quantum to obtain a significant advantage over all its classical counterparts. Based on these two points, not fully quantum key distribution was first introduced by Boyer et al.1 where secure key distribution becomes possible when one party Alice is quantum, yet the other party Bob has only “classical” capabilities, which means someone is limited to perform the following four operations: (1) prepare qubits in the computational basis , (2) measure qubits in the computational basis , (3) reorder qubits and (4) access quantum channels. The party Bob with such limitation is customarily called “classical” Bob and this kind of protocol is termed as “quantum key distribution with classical Bob” or “semiquantum key distribution (SQKD)”.
The first SQKD protocol was proposed in 2007 by using four quantum states, each of which is randomly prepared in the rectilinear or diagonal basis1. The idea was extended further and two similar protocols were presented in ref. 2. One is based on measurement and the other is based on randomization. Almost simultaneously, ref. 3 showed the SQKD protocol in ref. 1 can be simplified by employing less than four quantum states and proposed five different SQKD protocols using three quantum states, two quantum states and one quantum state, respectively. In 2011, a more efficient SQKD protocol was proposed based on entangled states4, where the qubit efficiency is improved to 50%, compared with 25% of the protocol in ref. 1. Recently, ref. 5 proposed an SQKD protocol in which the “classical” party does not need the measurement capability and just needs preparing, sending and reordering qubits. All these SQKD protocols generally assume the existence of an authenticated classical channel, which can be removed by preshareing a master secret key between two communicants6. Furthermore, several multiuser SQKD protocols were put forward7,8,9. The protocol in ref. 7 allows quantum Alice to share a key with several “classical” participants Bob1, Bob2, , Bobn. The protocols in refs 8,9 allow two “classical” participants to generate a shared key with the aid of an untrusted quantum server. In addition, other semiquantum cryptographic issues beyond SQKD have also been studied to some extent10,11,12,13,14.
However, in the all above-mentioned semiquantum cryptographic protocols, so-called “classical” users are not really classical since they still need some quantum ability of preparing and measuring qubits in the computational basis, or quantum memory to reorder qubits. That means they still require corresponding quantum devices to perform certain operations. Then we give a protocol for a nearly classical party Bob who does not possess any quantum device except those necessary for accessing quantum channels to share a key with quantum Alice by the delegation of quantum computations (DQC). In other words, such Bob does not need to implement operations (1), (2) and (3) and only requires the ability to perform the operation (4). But in the presented protocol, there may be not only an independent eavesdropper Eve attempting to obtain some information about the shared key, the delegated server Charlie also may become a powerful adversary. Note that the delegated server can be Alice if she can implement some complicated quantum operations that Charlie needs. But in this case, Charlie becomes a trusted quantum server and Eve is the only attacker. It is obvious that any attack that Eve tries to do may be absorbed into the untrusted Charlie’s attack. Therefore, we will show the proposed SQKD protocol is robust like typical SQKD protocols even when Charlie is malicious.
In this section, we first describe the protocol which will be shown to be realized with current technology and then analyze its security and compare it with other typical SQKD protocols.
We begin to present the SQKD protocol where nearly classical Bob can generate a shared key with quantum Alice, by delegating his quantum computation to a quantum server Charlie. Let n and m be the desired number of sifted key bits and final shared key bits, δ > 0, θ > 0 and σ > 0 be certain fixed parameters and l be the transmission speed threshold of qubits which will be useful for the security of the protocol. The detailed steps of the protocol are given as follows.
(S1) Alice prepares  qubits at random and sends them to Bob with a speed greater than or equal to l. Each qubit  is one of the four states , where . Here  can been regarded as the encrypted result of another state. For example, Alice first randomly produces a state  and then applies XaZb on it to get , namely , where a and b are randomly chosen from  and made up of the encryption key.
(S2) As each qubit  arrives, Bob randomly decides whether to discard the qubit directly or not. For the qubit  that Bob did not throw away, Bob records its position  , transmits it to Charlie and ask him to apply the Pauli gate  which is randomly chosen from . We should note that the transmission speed of qubits should be quick enough so that Charlie or other attackers cannot distinguish Bob’s choices. We assume that the qubit-transmission speed threshold during Bob’s reception is l for preventing attackers to learn Bob’s random choices. If Bob observers the speed value is smaller than l, he aborts the protocol and starts a new one.
(S3) After performing the operation  required by Bob, Charlie reflects the qubit  back to Bob still at a speed no less than l.
(S4) For each qubit coming from Charlie, Bob chooses either throws it away, or sends it to Charlie again and asks him to measure it in the rectilinear basis R or diagonal basis D. Bob also observes the transmission speed of qubits and then decides whether to continue.
(S5) Charlie performs corresponding measurements on the qubits and sends all the measurement results  to Bob, where .
(S6) Alice announces the basis corresponding to the state of each qubit  she prepares. For instance, if , Alice announces R, otherwise reveals D.
(S7) Bob tells Alice the positions where he chose right bases and then they discard the bits in other positions. There is a high probability that at least 2n positions that Alice and Bob should agree. Suppose these agreed positions be indexed by . If  was prepared in  or , Alice interprets the bit as 0, otherwise interprets it as 1. But for qubits in positions , there are four cases occurring in the same probability from the perspective of Bob: (1) the Pauli gate X and measurement in the basis R are applied, (2) the Pauli gate X and measurement in the basis D are applied, (3) the Pauli gate Z and measurement in the basis R are applied and (4) the Pauli gate Z and measurement in the basis D are applied. For cases (1) and (4) Bob interprets the bit as  and interprets it as  for the other two cases. By this method, Alice and Bob keep 2n bits.
(S8) Alice and Bob publicly announce and compare n bits to check for eavesdropping and Charlie’s dishonesty. If their disagreements exceed an acceptable number, they abort the protocol. Otherwise, they take the remaining n bits as a sifted key.
(S9) Alice and Bob perform purely classical information reconciliation and privacy amplification on the n-bit sifted key to obtain the final m-bit shared key.
The above protocol can be illustrated by a specific example as shown in Fig. 1. In addition, the presented protocol only needs simplified experimental requirements of quantum key distribution plus Pauli gates X and Z, which can be experimentally realized using today’s technology22. As for the transmission speed threshold of qubits for ensuring attackers unable to know Bob’s random choices, namely either to discard qubits or transmit them to the delegated server for further operations, it may be not difficult to achieve since one can currently expect at least 1.02M qubits per second for a fiber distance of 20 km and 10.1 K qubits per second for 100 km34.
An example for the proposed SQKD protocol.
An SQKD protocol is usually said to be robust if for any attack of an adversary to gain information will necessarily induce some detectable errors. We show the robustness of the proposed protocol mainly in a reduction way, with the only difference that there is an assumption on the attacker. In this protocol, attackers are not all-powerful since they are supposed to be unable to distinguish the almost classical party’s random choices when a string of unknown qubits arrive.
We first consider a special case that Eve exists only between Alice and Bob without knowing the delegated server. Then from the perspective of Eve, since nearly classical Bob can delegates all his quantum operations to Charlie for obtaining the corresponding results, the proposed protocol (Protocol 1) can be reduced to a protocol (Protocol 2) where Alice and Bob implement a quantum key distribution protocol, similar to the famous BB84 protocol35 with modifications that Bob randomly discards some qubits, or applies Pauli gates on them and measures some of them in the bases R or D at random. Thus Protocol 2 can obtain the similar level of security as the BB84 protocol, but sacrificing qubit efficiency and so is the Protocol 1 in this case. For example, we can suppose Eve intercepts all the qubits and measures them in the bases chosen by himself. As Eve cannot know which positions Bob chose to apply Pauli operators and perform measurements, in each position she only has a probability of 1/4 to guess the two choices right and escapes from being detected with the probability . Then the probability that Eve goes undetected is , compared with  of the BB84 protocol.
In a more general scenario, Charlie may be dishonest and also attempt to obtain some information about the shared key between Alice and Bob. We can assume there is no other third-party eavesdroppers since their attacks can be absorbed into an attack initiated by a malicious Charlie. In addition, there should be an authenticated classical channel between Alice and Bob that is normal in SQKD protocols. The classical channel from Charlie to Bob is unnecessary but better to be authenticated, since an authenticated channel can increase the successful rate of the protocol. From the server Charlie’s view of Protocol 1, he preforms the protocol similar to the reviewed DQC protocol15 with Bob and also can intercept and operate on all the qubits that were sent by Alice to Bob like an eavesdropper. We consider the security in two cases according to whether Charlie initiates eavesdropping on the quantum channel between Alice and Bob.
If Charlie does not wiretap when Alice sends qubits to Bob, the security of Protocol 1 mainly depends on the employed DQC protocol. Thus Protocol 1 can be reduced to a modified DQC protocol, namely Protocol 3, which can be modeled as follows:
(D1’) Alice sends to Bob a state  of N qubits, each of which is either , , , or . The state  can be obtained by applying quantum one-time pad on another state  with two key strings K1 and K2, namely . When Bob receives each qubit, he randomly decides to discard it or transmit it to Charlie. So the state  that Charlie receives is a totally random subsystem of . It can be seen that Bob encrypts  to get .
(D2’) Charlie implements corresponding quantum computation U on  using the reviewed DQC protocol15.
(D3’) Different from the step D3 in the reviewed protocol, Charlie not only returns Bob the resultant state , but also sends Bob the measurement outcomes of half qubits of  randomly chosen by Bob.
According to the security analysis in ref. 15, Charlie cannot learn anything about  and  from . Even if in the step D3’, Charlie are required to perform measurements on some quibts, which can be regarded as that Bob asks for classical output instead of quantum output, Bob still should not find any information about  and , otherwise the reviewed DQC protocol15 cannot keep the client’s data private. Thus, Protocol 1 is as secure as Protocol 3 before public discussion.
The process of public discussion is not only used for Alice and Bob to obtain the shared sifted key bits, but also provides a method to verify whether Charlie follows the protocol to some extent. Although Alice and Bob reveal the bases of qubits where they have the same choices, Charlie still cannot learn the bits since he does not know which qubits Bob chose Pauli X or Z operations and thus cannot know whether he should flip the measurement outcomes or not. In addition, if Charlie alters the transmission or does not perform the operations as required, extra disagreements will be induced on some of the bits that Alice and Bob think they should agree.
If Charlie controls the quantum channel from Alice to Bob, the security of Protocol 1 does not just depend on the employed DQC protocol since the qubits that Bob receives may not be the real ones from Alice. We consider the worst case that Charlie intercepts all the qubits sent by Alice and replaces them with his own ones, such as those randomly chosen from  instead of , . Then no matter which qubits Bob chose to forward in step S2, Charlie can distinguish these orthogonal states and learn Bob’s choices. Similarly, Charlie also can figure out Bob’s further choices in step S4 by measuring all the coming qubits in the same basis R. By doing so, Charlie can learn whatever Bob does. However, during the public discussion, for each position that Alice and Bob chose the same basis, there still has a disagreement between Alice and Bob with a probability 1/2 since Charlie did not know the original states that Alice prepared. So the probability that Charlie is not noticed is  which approaches zero when n is big enough.
In existing SQKD protocols1,2,3,4,5,6,7,8,9, one party with limited quantum power usually needs to perform three or four of the following quantum operations: (1) prepare qubits in the computational basis , (2) measure qubits in the computational basis , (3) reorder qubits and (4) access quantum channels, while in the proposed protocol, the party needs to implement only operation (4). In other words, compared with the related work, our main contribution is that the quantum requirement that one party should have the ability of preparing and measuring qubits in the computational basis, or reordering qubits in typical SQKD protocols is removed and thus such party is more classical. The detailed comparisons between the given protocol and some typical ones are shown in Fig. 2.
Comparisons among several SQKD protocols.
We have proposed an SQKD protocol by employing secure DQC where almost classical Bob who does not require quantum capability or quantum memory and only needs to access quantum channels can establish a shared key with quantum Alice. The quantum resources of one party in our protocol is restricted to the minimum, so more users will have chances to participate quantum key distribution and enjoy its advantage. We also have provided an application of the DQC protocol on encrypted data recently presented in ref. 15 and offered a verification method for it to some extent. Furthermore, this is the first time to build a bridge between QKD and DQC, the combination of which will play a significant role in the advancement of secure distributed quantum applications and throw lights on designing future quantum hybrid networks where quantum cryptographic communication and quantum computation are to be implemented.
However, we have to achieve this more practical SQKD protocol at the cost of sacrificing qubit efficiency which is only 12.5%, compared with 25% of the typical SQKD protocol1. It can be significantly improved if relaxing quantum requirements of the party with restricted power, such as allowing him to have memory for reordering qubits, but quantum memory is not an easy task with current technology. How to increase the key rate in the proposed SQKD protocol will be the future work.
