Solving search problems by strongly simulating quantum circuits
Simulating quantum circuits using classical computers lets us analyse the inner workings of quantum algorithms. The most complete type of simulation, strong simulation, is believed to be generally inefficient. Nevertheless, several efficient strong simulation techniques are known for restricted families of quantum circuits and we develop an additional technique in this article. Further, we show that strong simulation algorithms perform another fundamental task: solving search problems. Efficient strong simulation techniques allow solutions to a class of search problems to be counted and found efficiently. This enhances the utility of strong simulation methods, known or yet to be discovered and extends the class of search problems known to be efficiently simulable. Relating strong simulation to search problems also bounds the computational power of efficiently strongly simulable circuits; if they could solve all problems in P this would imply that all problems in NP and #P could be solved in polynomial time.
Ever since Shor famously showed that a quantum computer can factorise numbers super-polynomially quicker than the fastest known classical algorithm1, researchers have sought methods to efficiently simulate quantum circuits using classical computers. This is partly to narrow down where the power of quantum computers may arise and partly to understand the operation of quantum algorithms. Simulation is typically divided into two types, weak and strong2,3. Weak simulations sample an outcome of a measurement on a quantum circuit with the correct probability distribution. Strong simulations, which we focus on, go further, precisely calculating probabilities in this distribution.
The strong simulation of an arbitrary quantum circuit is widely believed to be inefficient, even using a quantum computer; in the language of computational complexity, it is #P-hard2. However several efficient methods are known for strong simulation using a classical computer, provided the process to be simulated is sufficiently restricted3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24. For example, Gottesman showed that stabiliser circuits acting on computational basis states admit efficient strong simulation if measurements are restricted to that basis4,5,6,7. Valiant demonstrated a similar result for circuits comprising matchgates8. This was later related to free Fermion systems and generalised to Gaussian circuits9,10,11,12,13. Further, utilising techniques for contracting tensor networks, Markov and Shi developed a method for efficiently simulating circuits composed of arbitrary gates arranged in a tree-like geometry22.
In this article we exploit that every strong simulation of a quantum circuit is represented by the contraction of a tensor network. We discuss how individual gates are represented by tensors and the pattern of connections between the tensors follows directly from the circuit. Contracting the resulting tensor network returns the strong simulation result. An advantage of the tensor network representation is that it acts as a unifying language for strong simulation algorithms and we use it here to demonstrate that concatenations of tree-like circuits followed by Gaussian or stabiliser circuits are efficiently strongly simulable. Another advantage of using the language of tensor network contraction is that it applies beyond quantum circuits, to classical Boolean circuits25 and their generalisation to stochastic circuits26.
Strong simulation algorithms efficiently perform restricted forms of what is thought to be a generally inefficient task. It is then worth investigating whether they might efficiently solve subsets of other generally difficult problems. In this regard, Aaronson and Gottesman showed that solutions to problems in the class ⊕L (parity-L)27 could be embedded in the probabilities of stabiliser-circuit measurement outcomes and thus efficiently solved using methods to simulate such circuits5. Moreover, following Valiant, it has been shown that matchgate circuit simulators and the related holographic algorithms, provide an efficient means to solve problems for which none were previously known28.
This article is similarly motivated; we show that every efficient strong simulation technique provides a method for efficiently solving a class of search problems. We do this by constructing, for any given search problem, circuits that check solutions to the problem and whose strong simulation counts and reveals solutions to the problem. A search problem is then efficiently solvable if these strong simulations can be performed efficiently.
The importance of search problems stems from the wide variety of tasks that can be phrased in terms of them29. Further, by connecting strong simulation to search problems we highlight the relationship between strong simulation and well-known complexity classes: the problems decided by efficiently strongly simulable circuits must form a proper subset of P, otherwise P, NP and #P are all equally powerful.
A search problem is a collection of instances, each represented by a bitstring x and associated with a set of solutions S(x)29. Each solution w ∈ S(x) is also represented by a bitstring. A search problem is efficiently solvable if, for every instance x, it is possible to find a solution w ∈ S(x) or determine none exists in a time ≤ p(|x|). Here p is some polynomial and |x| is the length of bitstring x. This is consistent with the general notion of efficient, meaning that a task can be completed in a time upper-bounded by a polynomial in the size of its description. In what follows, we assume that solutions can be efficiently checked using a classical computer and efficiently described.
Our approach relies on the reduction of a search problem to a counting problem29. Each instance of the counting problem, described by (x, n, w′), is to calculate #(x, n, w′) the number of solutions to x that are of length n and end in some bit pattern w′.
The reduction, depicted in figure 1, is performed as follows. For a given x with Null the zero-length bitstring, calculate #(x, n, Null) for n  =  1. Repeat this for n  =  2, 3,… until either a non-zero value of #(x, n, Null) is obtained or n reaches some maximum value nmax. If nmax is reached without obtaining a non-zero value, then no solution exists. If instead a non-zero value is found for some n  =  |w|min ≤ nmax, then a length-|w|min solution exists. To find one such solution, complete the following binary search. Evaluate #(x, |w|min, 0). If this is non-zero, calculate #(x, |w|min, 00). Otherwise, calculate #(x, |w|min, 01). Continuing in this way, a length-|w|min solution to x is inferred after a total of 2|w|min counts.
Searching by counting.
A solution to a search problem instance x can be inferred from a sequence of a small number of counts. In the example shown there is a single solution S(x)  =  1001 and each blue circle represents an enumeration of solutions to x of length 4 ending in suffix w′. An empty or filled circle indicates that the count returned zero or one, respectively. The red dotted line shows the path to the solution inferred from these counts. For the first count (upper most circle), w′ has zero length, i.e., all solutions of length 4 are counted and we infer there is a solution of this length. For the next count  and we infer that solutions must begin with suffix 1. For the third count  and we infer that there is a solution beginning with suffix 01 and so on.
Since solutions are efficiently described, we may choose nmax ≤ p(|x|) and this results in two properties: first, x is solved by calculating #(x, n, w′) for ≤ p(|x|) values of n and w′; second, for these n and w′ we have |(x, n, w′)| ≤ p(|x|). It follows that if the counting problem is efficiently solvable then so is the search problem.
To highlight the computational difficulty (#P-hardness) of strong simulation, researchers have constructed quantum processes with outcome probabilities encoding the solutions to hard counting problem instances2. We encompass such approaches by constructing a quantum process whose outcome probabilities embed the solution to an arbitrary counting instance (x, n, w′). Our motivation, unlike in Ref. 2, is not to suggest the general inefficiency of strong simulation but to take specific cases in which it is efficient and transfer this efficiency to solving the embedded counting instance.
We now outline the quantum process, leaving the details of its construction to the methods section. The quantum process consists of an input state, a quantum circuit and a measurement. Each possible solution w of length n is represented by an N-qubit product input state 
where {|0〉, |1〉} is the computational basis. Input states are evolved according to a quantum circuit Cx,n comprising M gates, with each gate gk acting on a bounded number of qubits. The unitary operator representing this circuit is 
Finally, a measurement is performed, defined by some projectors  with outcomes {yes, no}. Here we choose  to project onto a computational basis state of the last qubit 
The circuit Cx,n is devised such that if w ∈ S(x) then Ĉx,n|w〉 is in the range of , otherwise it is in the range of . We call a circuit with this property a solution-checking circuit: if |w〉 is inputted into Cx,n then measuring the output returns yes with probability equal to unity if w ∈ S(x) and otherwise zero. Then, by linearity, inputting a superposition 
into Cx,n returns yes with probability . Here W(n,w′)  =  {w″w′ : |w″w′|  =  n} is the set of length-n bitstrings with suffix w′,  is a normalisation constant with n′  =  |w′| and .
We call this process a quantum counter since its outcome probabilities encode #(x, n, w′) and thus (x, n, w′) is solved by its strong simulation. It is essential that the simulation is strong, as the prefactor  means that probabilities must be calculated to a precision exponential in n. Generally, an exponential number of weak simulations would be required to achieve this precision2,3.
To ensure no inefficiencies are hidden in the construction of the counters, we insist that for every (x, n, w′) a description of the counter can be generated in a time ≤ p(|(x, n, w′)|). A family of counters obeying this restriction is called (polynomial-time) uniform. The uniformity of a family of counters is ensured if we impose two conditions on the family {Cx,n} of solution-checking circuits on which they are based: circuits in the family are of polynomial size, i.e. N, M ≤ p(n) for each Cx,n and the family is uniform, i.e. a description of each Cx,n can be generated in a time ≤ p(|x|, n). In this article all families of counters are uniform and all families of circuits are polynomially-sized and uniform.
Given these restrictions, a search problem is efficiently solvable if there is a family of counters that are also efficiently strongly simulable. An efficient strong simulation method will efficiently strongly simulate some families of counters and thus efficiently solve some counting and search problems. This is one of the main implications of our formulation.
In the remainder of this article we will identify counting and search problems efficiently solved by known and newly-devised strong simulation methods. However, we first describe the tensor network representation of strong simulation, which provides a convenient language for discussing these strong simulation methods.
The strong simulation of a quantum counter reduces to calculating the probability 
The N-qubit states and operators appearing on the right hand side of equation (5) are made up of single-qubit states and operators acting on a bounded number of qubits, according to equations (2)–(4). As is common in quantum mechanics, we may represent these states and operators by vectors and matrices, respectively (see methods). In this way, the operation  and each of the M operations that constitute Ĉx,n is described by a matrix of bounded size. Similarly, the initial product state |W(n,w′)〉 is described by N vectors of bounded size. Thus there is a set of 2(M + N) + 1 tensors that together efficiently describe the quantum process. Contracting these tensors together in the correct arrangement to obtain equation (5) reveals #(x, n, w′). Hence we call the tensor network, illustrated in figure 2, a tensor counter.
Tensor counter.
A tensor network whose contraction reveals the solution to a counting problem instance (x, n, w′). Each shape represents a tensor and each line leaving it corresponds to one of its indices. A connection between two shapes represents a contraction, or joint sum over the corresponding indices. This tensor counter generalises the expression in equation (5), written at the top of the figure, for the probability of a measurement outcome following a quantum circuit. For clarity, tensors representing ancilla bits have been absorbed into the network representing the solution-checking circuit Cx,n. This circuit may be quantum, stochastic or Boolean (shown above).
A family of tensor counters constructed in this way inherits its uniformity from the family of quantum counters on which it is based. In this representation then, a search problem and its corresponding counting problem are efficiently solvable if there is a family of tensor counters that are efficiently contractable. This is ensured if each counter can be contracted in a time ≤ p(n).
We now discuss cases in which counters of the type in figure 2 are efficiently contractable and thereby identify efficiently solvable counting and search problems. Since the other parts of the counters are fixed, the efficiency of their contraction depends only on the family {Cx,n} of solution-checking circuits. This leads to the following result: a search problem is efficiently solvable if its solutions can be checked by restricted circuit families, specifically circuit families which correspond to efficiently contractable counters. Before we identify such circuit families, let us comment on the applicability of our results to various circuit types. We have so far outlined one approach to constructing a family of tensor counters of the form shown in figure 2, based on a family {Cx,n} of quantum solution-checking circuits. However, as we show in the methods section, there are other equally valid approaches. As an example, we describe an explicit construction for a family of tensor counters based on a family {Cx,n} of classical Boolean solution-checking circuits. Tensor counters can also be constructed from circuits {Cx,n} within other models of computation. For example, stochastic circuits26 and atemporal Boolean circuits25, both of which are a generalisation of Boolean circuits.
Thus what follows applies to tensor counters built from solution-checking circuits {Cx,n} within any such computational model. This increases the number of routes through which one may devise a family of efficiently contractible counters and demonstrate the efficiency of finding and counting solutions to a search problem. For notational convenience, we treat the solution-checking circuit Cx,n and the tensor network representing it as synonymous, only making a distinction when needed for clarity. Methods for contracting tensor networks are divided into two types; geometric and algebraic.
Geometric methods sequentially perform a contraction while carefully choosing the contraction sequence to avoid storing or manipulating large tensors. Accordingly, when discussing these methods, the only concern is with the structure of the counter. The counter inherits the same structure as Cx,n up to a bounded increase in the size of the tensors, as illustrated in figure 3(a). Therefore the efficiency of geometric methods depend solely on the geometries of {Cx,n}.
Contraction strategies.
(a) Folding a tensor counter and merging the tensors in each of the blue or red shaded regions reduces the counter to a network with the geometry of the solution-checking network Cx,n. If Cx,n has a tree structure, as is shown, then the counter can be contracted efficiently in the order labelled, starting from 1. (b) A Gaussian or stabiliser circuit acting on the local projection operator returns a matrix product operator of bounded size. This can be efficiently contracted with the initial state in the order labelled. (c) If Cx,n is the concatenation of a tree-like circuit followed by a Gaussian or stabiliser circuit then the counter may be efficiently contracted in the following way. Firstly, as in (b), the action of the Gaussian or stabiliser circuit returns a matrix product operator. Secondly, as in (a), folding and merging returns a network with the same geometry of the tree-like circuit, which may be efficiently contracted.
As an example of a geometric contraction strategy, consider the case where each of the circuits in {Cx,n} has a simple tree structure. The counters can then be efficiently contracted by starting at the branch tips and moving inwards, as indicated in figure 3(a). Thus search problems are efficiently solvable if their solutions can be checked by a family {Cx,n} of circuits whose gates are arranged in a simple tree structure. Markov and Shi generalised this contraction strategy by showing how to efficiently contract networks that are sufficiently tree-like22. Specifically, a family of networks is efficiently contractable if each network has a treewidth (a measure of how far a network is from being a tree) growing at most logarithmically in the number of tensors. It follows from our formalism that this same contraction strategy efficiently solves any search problem whose solutions are checked by a family {Cx,n} of circuits with a treewidth growing at most logarithmically in n.
We can immediately apply this result to the problem of finding satisfying solutions to a restricted version of the Boolean satisfiability decision problem30. For this search problem, each instance x describes a Boolean formula and each solution w ∈ S(x) is a length-n bitstring representing a set of n Boolean variables which satisfy this formula. Provided we restrict ourselves to formulas represented by circuits {Cx,n} with a treewidth growing at most logarithmically in n, solutions are checked using such restricted circuits. Hence such restricted SAT-based counting and search problems are efficiently solvable using our approach.
Other contraction strategies rely on algebraic relations to simplify or fully contract a tensor network; in this case it is not only the geometry of the network that is important, but also the components of the tensors. Two prominent examples are the methods of simulating stabiliser4,7 and Gaussian circuits12,13, the latter of which encapsulates matchgate and free Fermion circuits8,9,10,11. Each is based on a group of operators which, under the action of a restricted circuit, map to other operators in the group. Algebraic relations allow this mapping to be calculated efficiently.
Specifically, for either a stabiliser or Gaussian circuit Cx,n, the evolved projection operator , appearing in the counter shown in figure 2, can be found in a time ≤ p(n)7,13. This evolved projector is described by a particularly simple form of tensor network with ≤ p(n) tensors of bounded size arranged in a linear geometry (see methods). This network, called a matrix product operator31,32, is illustrated in figure 3(b). Using the strategy suggested in this figure, the simple geometry of the matrix product operator allows the full counter to be contracted in a time ≤ p(n). Thus a search problem is efficiently solvable if its solutions can be checked by a family {Cx,n} of stabiliser or Gaussian circuits.
For stabiliser circuits, this has a clear interpretation in terms of a known class of decision problems. A decision problem is defined as a collection of instances the solution to which is either yes or no. The problem is fully specified by the set of all yes instances, called the language and the bitstrings describing yes instances are words in this language. The class ⊕L contains every language for which it can be decided whether any word is a part of that language using a stabiliser circuit acting on computational basis states followed by a single measurement in that basis5,27. Using our formalism, it is then efficient to count and find words from any language in ⊕L.
Our formalism also allows the efficient finding of words in languages decided by a Gaussian circuit followed by a computational basis measurement in a single qubit. It turns out that such languages are trivial; whether or not a word is part of the language can be decided by considering at most a single bit of the word33.
Having presented several strong simulation methods in the unifying language of tensor networks, we now show that they can be combined. We have already shown that evolving  by a stabiliser or Gaussian circuit  returns a matrix product operator. In figure 3(c) we depict how a bounded matrix product operator evolved by another circuit  leads to a network with the same geometry of  but with a bounded increase in the size of the tensors. This means it is possible to contract each counter in figure 2 in a time ≤ p(n) if Cx,n is a concatenation of a circuit  with a treewidth growing at most logarithmically in n followed by a stabiliser or Gaussian circuit . Thus we have arrived at a key result: a search problem is efficiently solvable if its solutions are checked by a family {Cx,n} of such concatenated circuits. The class of search problems of this type was not previously known to be efficiently solvable.
The above joint algebraic and geometric contraction strategy encapsulates each of the three strong simulation algorithms considered (stabiliser, Gaussian and tree-based) and in their combination leads to a new class of efficiently simulable quantum circuits.
It is known that there is a sudden shift in computational power when a seemingly innocuous gate is added to the gatesets of either Gaussian or stabiliser circuits: Since they are efficiently simulable, (uniform and polynomially-sized) Gaussian or stabiliser circuits followed by a computational basis measurement cannot be used to decide, even with a bounded error, any languages outside the complexity class P, where P is the class of decision problems solved efficiently and without error using a classical computer. However, if SWAP13 or the π/8-gate34, respectively, are added to either gateset, then either can decide problems in BQP. This is the class of decision problems solved efficiently and with a bounded error using a quantum computer.
The shift is enhanced by both our concatenation of simulation techniques and our algorithm for searching by simulating. The former narrows down where the shift may take place: allowing bounded-size, but otherwise arbitrary gates, in a limited geometry before Gaussian or stabiliser circuits does allow the deciding of languages beyond P with bounded error. The latter highlights the size of the shift: we expect the languages that can be decided without error using Gaussian, stabiliser, tree-like circuits, or their concatenation followed by a computational basis measurement not only to be a subset of P, but a proper subset. To see why this is expected, consider the opposite to be true. This would imply that all efficiently-checkable search problems can be checked using Gaussian, stabiliser, tree-like circuits, or their concatenation followed by a computational basis measurement. Using our formulation, it would then be possible to efficiently count and find solutions to all efficiently-checkable search problems. Note that each instance of a problem in #P (NP) corresponds to counting the number of solutions (deciding whether there is a solution) to an instance of an efficiently-checkable search problem29. Thus all problems in NP and #P would be solvable in polynomial time.
Our results reveal a hitherto unknown consequence of algorithms that efficiently simulate quantum circuits; each allows for the efficient solving of a class of search problems. This applies to every strong simulation technique, implemented by any device, classical or quantum. For well understood methods such as stabiliser circuit simulation algorithms, this confirms what is already known. For methods whose computational power is less well understood, this demonstrates the efficient solubility of several classes of search problems based on how their solutions are checked. To our knowledge, this extends the class of counting and search problems known to be efficiently solvable. Further, the most general technique considered in this article corresponds to a novel combination of strong simulation methods. Hence this article widens the class of efficient strong simulation methods and adds to their applicability.
Here we give an explicit approach to constructing a quantum solution-checking circuit Cx,n used to form a quantum counter.
For every instance x of an efficiently-checkable search problem a solution of length n can be checked in time ≤ p(|x|) using a classical computer. Thus there is a classical algorithm that decides the language  in time ≤ p(|(x,w)|). It is then possible to construct a family of Boolean circuits {Cm} with the following properties35: each Cm takes inputs (x, w) with |(x, w)|  =  m and outputs logical-one if  and otherwise logical-zero; it comprises ≤ p(m) AND, OR and NOT gates34; and it is constructible in a time ≤ p(m). Hardwiring x into Cm leaves a Boolean solution-checking circuit Cx,n that takes bitstrings w of length n and outputs logical-one if w ∈ S(x) and otherwise logical-zero.
The Boolean circuit Cx,n can be made reversible in time ≤ p(|x|, n) with only ≤ p(|x|, n) additional gates and ≤ p(|x|, n) additional ancilla bits, each initially set to zero36,37,38. The standard mapping between reversible classical and unitary quantum circuits34 leads to a quantum circuit of the desired form. This circuit is generated in time ≤ p(|x|, n) and comprises ≤ p(|x|, n) gates. So the approach leads to polynomially-sized uniform families of quantum solution-checking circuits and hence a uniform family of quantum counters for the search problem.
Here we describe how the expression for the probability  in equation (5) is replaced by the contraction of a uniform tensor network. Other descriptions of how to represent quantum circuits by tensor networks can be found in Refs. [15, 22].
To begin, insert equations (2)–(4) into equation (5) to obtain 
To rewrite this as a tensor network contraction, first replace the states and operators |0〉, |1〉, |+〉,  and |1〉 〈1| appearing in equation (6) by their corresponding tensors [0], [1], [+], {[gk]} and [|1〉 〈1|]. Specifically, represent each single-qubit state |ψ〉 by the tensor [ψ] with 2 components  labelled by an index i1  =  {0, 1}. To represent the dual of a state, take the conjugate transpose. Further, represent each N′-qubit operator  by the tensor [O] with 22N′ components 
labelled by 2N′ indices, where oj  =  {0, 1}. After this replacement, write a joint summation (contraction) over every pair of indices corresponding to an input and output connected by the expression in the right hand side of equation (6).
It follows from above that the mapping can be performed in a time ≤ p(|(x, n, w′)|). Thus a uniform family of quantum counters maps to a uniform family of tensor counters.
Here we describe conditions on the tensor network representing Cx,n, which appears in the counter shown in figure 2. The only requirement needed to ensure the contraction of the counter returns the desired value of  is 
where [Cx,n] is the tensor representing . In fact, it is not necessary for [Cx,n] to have the same number N of output indices as input indices. This gives us the freedom to consider a tensor network that does not represent a quantum circuit, but nevertheless whose contraction returns a tensor [Cx,n] satisfying equation (7).
Here we give an explicit approach to constructing a tensor counter built from a classical Boolean circuit.
In our construction of a quantum counter, we showed how to construct a solution-checking Boolean circuit Cx,n for any solution-length n and instance x of a given search problem. The circuit can be generated in a time ≤ p(|x|, n) and comprises ≤ p(|x|, n) bounded-size gates. It implements the binary switching function fx,n : {0, 1}n → {0, 1} where fx,n(w) is 1 if w ∈ S(x) and otherwise 0.
To obtain a tensor network representing Cx,n, first represent each gate implementing the binary function  by a tensor with components  where  and similarly for ok. Next connect the input and output indices of the tensors {[gk]} in precisely the same arrangement as the circuit. The components of the tensor obtained by contracting this network are . Again we have used the shorthand . This tensor satisfies equation (7). Thus the network representing Cx,n leads to a valid tensor counter of the form shown in figure 2. The counter is generated in a time ≤ p(|(x,n,w′)|) and so counters constructed in this way form a uniform family.
Using the Heisenberg picture, stabiliser circuits map a product of Pauli operators to another Pauli product7. Such a product is represented by a particularly simple matrix product operator where each tensor is the standard matrix representing the corresponding Pauli operator and the internal indices have dimension χ  =  1. With m the number of qubits, the projector  is the sum of two Pauli products and therefore so is . Two matrix product states can be efficiently summed to make another where the dimension χ increases additively31,32. Thus  is represented by a χ  =  2 matrix product operator.
Gaussian circuits map generators cµ of a Clifford algebra to a linear combination  where  is calculable in a time ≤ p(m) and ν takes 2m values13. Each cµ may be represented by a Pauli product13 and so  by a χ  =  2m matrix product operator. A product of two generators c1c2 is mapped to , represented by the product of two matrix product operators. The result is another matrix product operator where the dimension χ increases multiplicatively31,32. In this case the result has dimension χ  =  (2m)2. Finally, there is a choice of c1 and c2 such that 13. Thus  is represented by a χ  =  (2m)2 + 1 matrix product operator.
