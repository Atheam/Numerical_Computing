Quantum Annealing for Prime Factorization
We have developed a framework to convert an arbitrary integer factorization problem to an executable Ising model by first writing it as an optimization function then transforming the k-bit coupling (k ≥ 3) terms to quadratic terms using ancillary variables. Our resource-efficient method uses \({\mathscr{O}}({\mathrm{log}}^{2}(N))\) binary variables (qubits) for finding the factors of an integer N. We present how to factorize 15, 143, 59989, and 376289 using 4, 12, 59, and 94 logical qubits, respectively. This method was tested using the D-Wave 2000Q for finding an embedding and determining the prime factors for a given composite number. The method is general and could be used to factor larger integers as the number of available qubits increases, or combined with other ad hoc methods to achieve better performances for specific numbers.
Integer factorization reduces an integer N to its factors p and q such that pq = N. While this fundamental problem in number theory is computationally hard in practice, integer factorization is not believed to belong to the class of NP-hard problems. However, all known classical factoring algorithms which are deterministic and don’t have unproven hypotheses require time exponential in logN. For example, the fastest, known classical algorithm for integer factorization is the general number field sieve method1, which scales exponentially in the number of operations required with respect to the integer N. Thus, the integer factorization problem has been used as a basic hardness assumption for many encryption methods including the widely deployed RSA cryptographic system. With broad applications in cryptographic data storage and communications2, identifying new methods for integer factorization plays an important role in modern information security.
Quantum computing theory has the potential to reduce the number of operations required for solving the integer factorization problem. Within the circuit model of quantum computation, Shor’s algorithm is perhaps the most well-known method for integer factorization, in which the number of operations to factorize an integer N is polynomial in the size logN3. This exponential speedup over the general number field sieve is achieved by reducing factorization to the order-finding problem. Several experimental demonstrations using quantum computing hardware have validated the correctness of Shor’s algorithm for small integer values, including early work by Vandersypen et al.4 to factorize N = 15 using seven spin-1/2 nuclei in a molecule as qubits. Subsequent experiments by Lanyon et al.5, Lu et al.6, and Politi et al.7 implemented compiled versions of Shor’s algorithm using photonic systems for factoring 15. Martín-López et al.8 factored 21 using qubit recycling, and Lucero et al.9 used superconducting qubits to factor 15. Geller et al.10 used a simplified version of Shor’s algorithm for factoring products of the Fermat primes 3, 5, 17, 257, and 65537. Recent work from Grosshans et al. has shown how factoring safe semi-primes using the quantum order-finding algorithm can reduce the failure probability11.
An equally powerful model of quantum computing is the adiabatic quantum computing (AQC) model12,13, which can also solve the integer factorization problem. Peng et al. first developed integer factorization within AQC by reducing it to unconstrained optimization and solving this problem using adiabatic quantum dynamics. They further validated these ideas experimentally using a three-qubit NMR quantum processor for the case of N = 2114, while Xu et al. subsequently factored 143 using similar NMR technology15. Schaller et al. developed a novel approach based on multiplication tables that can be cast as an optimization, which they have demonstrated for biprimes up to N = 21716. Dridi et al. furthered these ideas by using Gröbner bases to reduce the number of auxiliary variables required and simplify equations, thereby enabling a demonstration of factorization up to 22335717.
In this contribution, we introduce a new procedure for solving the integer factorization problem using quantum annealing18,19 which utilizes adiabatic quantum computation. Differ from the recent work20 which sketched the hardware design of reversible multiplier to achieve factorization, we provide specific mathematical derivations to be tested on the existing hardware. We begin by describing a direct method for integer factorization that reduces the problem to unconstrained optimization. We review how this optimization problem can be reduced to a quadratic form Ising Hamiltonian and be solved using quantum annealing. We then describe a modified multiplication table method that reduces the overall resource requirements on the optimization problem and permits methods to account for constraints that may appear in quantum annealing hardware, such as connectivity and number of qubits. Our modification also reduces the range of coefficients in the underlying cost function without increasing the number of qubits required. This method avoided the time-consuming preprocessing steps17 to achieve comparable results, and could be combined with other ad-hoc function simplification methods to further reduce the number of qubits or other aspects. We finally tested both methods with results from experimental demonstrations using quantum annealing hardware.
Quantum Annealing was introduced18 to solve optimization problems using quantum fluctuations to transit to the ground state, compared to simulated annealing which uses thermal fluctuations to get to the global minimum. Quantum fluctuations such as quantum tunneling21 provide ways of transitions between states. The transverse field controls the rate of the transition, as the role of temperature played in simulated annealing.
Farhi et al.12 remodeled the procedure as Adiabatic Quantum Computing(AQC), which finds the energetic ground state of a problem Hamiltonian by adiabatically evolving the quantum state. If the system begins at the ground state, after the adiabatic evolution, the system will remain at the ground state. By combining the initial Hamiltonian HB and the problem Hamiltonian HP linearly, the system could be defined as a time-dependent Hamiltonian \(H(t)=(1-\frac{t}{T}){H}_{B}+\frac{t}{T}{H}_{P}\), where the duration T defines the time-scale for evolution and controls the rate at which the time-dependent Hamiltonian changes, the initial Hamiltonian HB is of the form \({H}_{B}=-\,{\sum }_{i=1}^{L}\,{\sigma }_{x}^{(i)}\) over L qubits with the Pauli operator \({\sigma }_{x}^{(i)}\) defining the x-basis of the i-th qubit. The problem Hamiltonian HP is in the form of Ising model over L qubits as
where \({\sigma }_{z}^{(i)}\) defines the z-basis for the i-th qubit and the local fields hi and couplings Jij define the problem instance.
Computation within the AQC model evolves the L-qubit quantum state under the time-dependent Hamiltonian H(t) according to the Schrödinger equation \(i\hslash \frac{\partial }{\partial t}|\psi (t)\rangle =H(t)|\psi (t)\rangle \), where |ψ(t)〉 is the state of the system at time t ∈ [0, T] and we will set ℏ = 1. Let |ϕi(t)〉 be the i-th instantaneous eigenstate, such that H(t)|ϕi(t)〉 = Ei(t) |ϕi(t)〉, and let the initial state of the system be the ground state at time t = 0, such that |ψ(0)〉 = |ϕ0(0)〉. According to the adiabatic theorem22, the system state will remain in the instantaneous ground state of the time-dependent Hamiltonian provided the evolution is sufficiently slow to prevent excitations to higher-lying states. Under these idealized adiabatic conditions, the system will evolve into the energetic ground state of the problem Hamiltonian as |ψ(T)〉 = |ϕ0(T)〉. This prepared quantum state of L qubits is then measured to generate a classical string of L bits that represents the solution to the encoded factorization problem.
Several practical considerations limit the applicability of the AQC model for solving optimization problems. Foremost is the requirement that changes in the quantum state must be adiabatic, i.e, slow, relative to the internal timescales of the instantaneous Hamiltonian H(t). Theoretical analyses of this requirement provide a best lower bound on the time T as O(Δ−2), where Δ is the minimum energy gap within the instantaneous eigen spectrum of H(t)13. However, the minimum spectral gap is dependent on the specific instances of the initial and final Hamiltonians and the interpolation between them. A priori knowledge of spectral gap information would provide a significant insight into the underlying optimization problem, if not the solution directly, and therefore is an impractical expectation for a computational method. In addition, the pure-state model for AQC fails to account for finite-temperature effects observed in actual hardware as well as unexpected environmental coupling, unpredictable control noise, unwanted crosstalk, and other imperfections.
Practically quantum annealing relaxes the AQC with guarantee that the observed final state corresponds to the energetic ground state. However, the probability to observe the energetic ground state may be reduced due to physical noise and non-adiabatic dynamics. The resulting error rate pe(L) characterizes the quantum annealing dynamics, which is most accurately modeled as an open quantum system of L-qubits evolving the presence of an uncontrolled environment. The quantum annealing model is therefore more robust to the above practical considerations but it is necessarily a probabilistic computational model. Statistical sampling of a quantum annealing computation is always necessary to gather confidence in the observed result. Quantum annealing may also be interpreted as a meta-heuristic for managing noisy AQC computation, whereby the aggregate likelihood of success ps is determined by the number of samples S as ps = 1−(pe)S. The number of samples necessary to achieve a desired probability of success is therefore S ≥ log(1−ps)/log(pe). For a fixed annealing duration T and probability of success ps, we may expect the probability of error p to increase as the size of the system increases, i.e., as L increases. The rate at which the sample number S increases with system size plays an important role in determining the computational complexity of using the quantum annealing model. For example, an error rate that increases exponentially with system size, i.e., pe ∝ exp(L), yields a sampling rate that increases linearly.
A related practical consideration is the resource efficiency with which quantum annealing can be implemented. Specifically, the number of qubits necessary to realize the problem Hamiltonian HP influences not only the number of samples required but also the feasibility of demonstrating the method on available hardware. The most general case of L-qubit Hamiltonian may include all-to-all connectivity, whereby each qubit must interact with every other qubits. However, most of the existing hardware does not permit such connectivity directly, and methods for realizing implicit connections have been developed23,24. In our implementation of integer factorization using the Ising Hamiltonian, it is necessary to compose a problem Hamiltonian in terms of pairwise interactions, and we develop an efficient transformation of the factoring problem Hamiltonian into pair-wise coupling.
We describe two methods for implementing integer factorization within the quantum annealing model. We found these two corresponding Hamiltonians HP to encode the factors of an input integer N, such that the energetic ground state corresponds to factorization of the input. The first is a direct method to compute the factors of N = pq by constructing the associated optimization problem as an Ising Hamiltonian. The second method is based on the modified multiplication tables to translate the problem into the Ising Hamiltonian. We test our methods using experimental quantum computing hardware appropriate for quantum annealing. The D-Wave 2000Q processor natively implements an Ising model Hamiltonian and provides programmable control over the parameters hi and Ji,j as well as the annealing duration T.
Our direct method factors N = pq, where p and q are prime numbers. We set \({l}_{1}=\lfloor {\mathrm{log}}_{2}(p)\rfloor \) and \({l}_{2}=\lfloor {log}_{2}(q)\rfloor \). Because p and q are prime numbers, we use the binary representations \(p={({x}_{{l}_{1}-1}{x}_{{l}_{1}-2}\mathrm{...}{x}_{1}\mathrm{1)}}_{2}\) and \(q={({x}_{{l}_{1}+{l}_{2}-2}{x}_{{l}_{1}+{l}_{2}-3}\mathrm{...}{x}_{{l}_{1}}\mathrm{1)}}_{2}\), where l1 > l2 and xi ∈ {0, 1} for i = 1 to l1 + l2−2. We define the cost function \(f({x}_{1},\,{x}_{2},\,{x}_{3},\,{x}_{4},\,\mathrm{...,}\,{x}_{{l}_{1}+{l}_{2}-2})={(N-pq)}^{2}\), and explicit multiplication of the binary representations for p and q yields a sum of binary products. We reduce the resulting 3-local terms to 2-local terms using the following equivalence24: for x, y, z ∈ {0, 1}, xy = z iff xy−2xz−2yz + 3z = 0, and xy ≠ z iff xy−2xz−2yz + 3z > 0. Therefore,
and
thus, the x1x2x3 term may be transformed to quadratic form by replacing x1x2 with x4 plus a constraint in the form of a penalty term:
By introducing a new variable and adding the penalty term, we are able to transform 3-local terms to 2-local terms.
For integer factorization, we require \((\begin{array}{c}{l}_{1}\\ 2\end{array})+(\begin{array}{c}{l}_{2}\\ 2\end{array})=\frac{{l}_{1}({l}_{1}-\mathrm{1)}}{2}+\frac{{l}_{2}({l}_{2}-\mathrm{1)}}{2}\) auxiliary variables to form a quadratic cost function, and when l1 = l2 = l this number is l × (l−1). Counting the variables to denote the factors themselves, the quadratic function requires L = 2 × (l−1) + l × (l−1) = (l + 2) × (l−1) binary variables in total. Since \(l={\mathscr{O}}(\mathrm{log}(N))\), \(L={\mathscr{O}}({\mathrm{log}}^{2}(N))\). We could also let \(p={\mathrm{(1}{x}_{{l}_{1}-2}\mathrm{...}{x}_{1}\mathrm{1)}}_{2},\,q={\mathrm{(1}{x}_{{l}_{1}+{l}_{2}-4}\mathrm{...}{x}_{{l}_{1}-1}\mathrm{1)}}_{2}\) when lengths of p and q are prefixed.
We illustrate this direct method of factorization for the case of N = 15. Because \({{\rm{l}}{\rm{o}}{\rm{g}}}_{2}(p)\,\le \,2\, < \,{{\rm{l}}{\rm{o}}{\rm{g}}}_{2}(q)\, < \,4\), we define p = (x11)2 and q = (x2x31)2. The objective function f(x1, x2, x3) = (N−pq)2 may then be reduced to the 3-local form:
We reduce the 3-local terms to 2-local terms using the method described above to obtain
where
This result is a quadratic unconstrained binary optimization (QUBO) problem over L = 4 variables that may be transformed into an equivalent Ising Hamiltonian as defined in Eq. 1 by identifying the binary variable xi with the i-th spin state si = 2xi − 1. For N = 15, the local fields hT and couplings J of the Ising problem Hamiltonian are then determined to be
and
It is notable that the L × L coupling matrix J is generally dense on the upper triangle, indicating that L(L−1)/2 couplings are necessary. Similarly Ising parameters may be generated for other integers N by the appropriate quadritization into a QUBO problem and then reduced to Ising form.
The second method is based on modified multiplication table. It reduces the range of Ising parameter values used as coefficients for the local fields and couplings. At the meantime, it considers to use a smaller number of carry variables without complicated preprocessing.
The modified multiplication table method uses local minimizations over the products of individual binary substring bits representing the integers p and q. It divides the multiplication table into several blocks, and considers each block individually. We could also choose the size of each block to get the desired range of parameters and the number of variables, or make a balance between them. A detailed analysis of the range of coefficients is shown in the last section of the supplemental material. Note that the modified multiplication table method does not eliminate the need for quadratization of 4-body and 3-body product terms and auxiliary variables are required. However, this approach does reduce the number of these higher-order terms compared to the direct method, which makes it possible to embed larger problem sizes on currently available quantum hardware.
We describe this method by an illustrative example of N = 143, for which p = 13 and q = 11. Past approaches for integer factorization constructed a system of equations from each column or part of each column in the multiplication table17,25,26, which accounts for a carry bit or several carry bits for each part. In our approach, we divide the multiplication table into blocks so that it is only needed to use carries between blocks. This greatly reduced the number of carries, thus the total number of variables reduced too.
As shown in Table 1 for N = 143, we introduce two sets of carry bits. We denote them using ci ∈ {0, 1}, and the two-bit numbers (c2c1)2 = c2 × 2 + c1 and (c4c3)2 = c4 × 2 + c3 represent the carry bits for each of the divided columns in the table. Note that the columns are composed along two-bit domains, so that addition within each block is over two-bit numbers. But the sums are over four-bit numbers. The resulting block system of equations derived from Table 1 is
Because this modified multiplication table method calculates carries only for each block, it avoids requiring carry bits for each column in the multiplication table. This reduces the overall complexity of the computation by reducing the number of carry bits as well as the number of couplings between bits. In the limit of a single column per block, the conventional multiplication table is recovered, while in the limit of a single equation the direct method is recovered. Instead of making the sum of each column equal to every each bit of the number to be factored as in a conventional multiplication table, we make each block of the multiplication table equal to the corresponding block of the number to be factored. As shown in the appendix material, the equations for these blocks may be reduced to the non-negative cost function
This form may be expanded and further simplified using the property \({x}_{i}^{2}={x}_{i}\,{\rm{for}}\,{x}_{i}=\mathrm{0,}\,1\), while the remaining cubic and higher-order terms like c1p1q1 and p1p2q1q2 can be reduced to quadratic form by introducing auxiliary variables. In particular, we note that the quadratization of the negative term is similar to the position term, e.g.,
as detailed in the appendix material, the conversion to QUBO form leads to the parameters for the Ising Hamiltonian. For N = 143, this yields the local fields
and the upper triangular coupling matrix
Our approach requires a decision to partition the columns of the multiplication table into blocks, and this choice must balance the number of unknown variables (carries) against the range of coefficients in the problem Hamiltonian. We illustrate this choice for the factorization of biprimes 59989 and 376289 in Tables 2 and 3. Our approach is to set the bit-length of the carry variable for each block based on the largest possible number of that block(the right neighboring columns). For example, the maximum carry for the right-most block in the multiplication table of N = 59989 is 3 which requires two bits to represent. Thus, the bit-length of the carry variable for this block is 2, i.e., (c2c1)2. Similarly, for N = 376289, the bit-length of the carry variables for the right-most block is 3, while the bit-length of the carry variable for the third block is 4. Because this bit-length is larger than the size of the fourth block, which has a bit-length of 3, the most significant bit of the carry is included in the neighboring block, i.e., the fifth block in this example.
We estimate the number of variables needed to construct the Ising Hamiltonian that encodes the factorization problem for N = 59989 and 376289. This requires quadratization of the resulting systems of factoring equations followed by reduction to the Ising form, exactly as discussed explicitly above. For the case of N = 59989, we have l1 = l2 = 6, and therefore 12 variables are required to represent the factors themselves plus 11 variables to denote the carries, while 36 auxiliary variables are required for quadratization of the factoring equations. The total number variables is 59. For N = 376289, we have l1 = l2 = 8 with 14 carries and 64 auxiliary variables. As noted above, sometimes vary bits in the multiplication table will overlap, as is the case for column 214 of 376289 shown in Table 3. In such circumstances, we just simply add these carries in the table and then use the same method as before to find the corresponding Ising Hamiltonian. Thus, this problem Hamiltonian requires 94 qubits.
Generally, for factoring a biprime number, we use approximately log(N) binary variables to encode the integer factors and about log(N) binary variables to denote the carries where N is the number to be factored. An additional log2(N)/4 auxiliary binary variables are required for quadratization. Therefore, a total of approximately log2(N)/4 binary variables are required to represent the problem Hamiltonian and, consequently, a similar number of qubits must be available within hardware. As a point of reference, applying this method to the current factoring record for RSA-768 would require approximately 147456 qubits.
